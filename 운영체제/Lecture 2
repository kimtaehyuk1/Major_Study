*프로세서
여러개의 응용프로그램 돌림, 프로세서가 여러개 응용프로그램을 돌아가면서 수행시켜주고 싶다.
최대한 프로세서가 놀지않으면서 성과 많이내도록 왜? IO장치 많기 때문에 프로세서 여유롭다
따라서 어플리케이션 각각을 프로세서로 만들어서

*기본적 필요한거
코드가 있어야됨(=instruction=text=program) 이건 같은 프로그램인데 여러 프로세서 공유
데이터필요
데이터는 크게 3가지 있는데
Stack heap(이둘은 dynamic 스택은 로컬변수 힙은 멜록해서 쓰는거) data(이건 static 글로벌변수)
이건(코드와데이터) 원래 프로그램에도 있던거, 프로그램이 메모리 올라가면 프로세서가 된다.

*Process Control Block(PCB) 프로세서를 제어하기 위한 덩어리, 운영체제별로 있다. c언어로 짤때 str으로 구현
프로세서 이미지(코드,데이터 외)부가적인 모든 요소가 들어가야됨
기본적으로 운영체제가 생성해서 관리하는거다
요소들
Identifier (pid) 프로세서 아이디
State 돌고있는지 아닌지
Priority 우선순위

Program counter - IAR instruction주소 현재 어디 돌리고있는지 
Memory pointers 여러가지 포인터들 있다 이것도 레지스터
Context data - 이것도 CPU context cpu안에서 메모리 레지스터 밖에없다
이것이 잘 보존되어야 여러 프로세서 같이 쓰게 하려면 cpu 문맥 잘 보존
위 세가지는 전부 context data일종이다 cpu 레지스터값 복사본이다 이 셋은

IO 상태 정보
Accoounting information etc...

*용어
Trace
이거는 instruction이 어떻게 수행되는지 나오는거 결국 pc값이 나오는거
Dispatcher(운영체제의 일부,스케쥴러같은말인데 다른점이 이건 프로세서를 다른 프로세서로 돌리는 그런 느낌)
어떤 프로세서를 쓸건지 결정해서 돌리는놈

!!!!!(표나 사진은 프린트 참조하고) 프로그램 바뀔때마다 dispatcher이 있다!!가장중요하고 앞에선 연속된거 처럼 보였지만 절대 연속된것이 아니다 왜그럴까??
여러개 프로세서즉 여러 응용프로그램이 한번에 수행하고 있는 환상이지 근데 중간중간 dispatcher로 돌았기 때문에 가능
사이사이에 운영체제가 time out이나 IO Request를 걸어논다.


여러  state들의 사진과 설명은 프린트를 참조한다

프로세서 생성
fork = spawning = creat(과제에서 라이브러리써서 Tread부르는거 처럼) 이것들 다 System call
프로세서 죽는거
정상적으로 끝나서, 메모리 용량이 부족해서, fault(cpu나 메모리상의 에러),os가 일부러 죽인다,부모 프로세서가 끝난다.

운영체제안에 프로세서 관리하는 pcb말고도 여러 하드웨어 제어하는 테이블 형태같은 자료구조가 있다는거

os가 이 3가지 경우에만 돈다
Interrupt,Trap,System call 이 부분의 자세한 부부은 프린트로 복습은 했으나 조금 에매한 부분을 더 공부후 








